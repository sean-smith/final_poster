\documentclass{lposter}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{booktabs}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{alltt}
\usepackage{textcomp}
\usepackage{url}
\usepackage{amssymb, amsthm, bm}
%\usepackage{semantic}
\usepackage{eso-pic}

\newcommand\BackgroundPicture{%
\put(0,0){%
\parbox[b][\paperheight]{\paperwidth}{%
\includegraphics[width=\paperwidth,height=\paperheight,%
                   keepaspectratio]{BUCS}%
\vfill%
}}}

\AddToShipoutPicture{\BackgroundPicture}
\bibliographystyle{alpha}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{rem}{Remark}
\newtheorem{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{ex}{Example}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\OC}{\mathcal{O}}
\newcommand{\bi}{\textbf{i}}

\renewcommand{\tt}[1]{\texttt{#1}}
\newcommand{\tts}[1]{\tiny{\texttt{#1}}}
\newenvironment{myprogramtext}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\small\bfseries}
{\end{list}}

\department{Computer Science}
\author{Sean Smith, Kyle Holzinger, Amalia Safer}
\year{2015} \class{Network Security} \advisor{Sharon Goldberg}
\title{Security Analysis of Github}

\providecommand{\bibtex}{{\rmfamily B\kern-.05em%
    \textsc{i\kern-.025em b}\kern-.08em%
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\pagestyle{fancy}

\begin{document}
\begin{poster}

%Abstract
%Problem
%Significance
%Approach
%results/observations

%\begin{itemize} \item \end{itemize}

%\begin{figure}
%\centering
%\includegraphics[scale=0.5]{mount}
%\caption{Motor Mount\newline}
%\label{fig:mig_over}
%\end{figure}


\section{Cookies}

A session cookie called \tt{user\_session} is stored which contains a seemingly random nonce. When a get request is made to \tt{https://github.com}, the cookie is sent and the database is queried to see if the cookie is valid. If the cookie is valid it will return user data as if the user is logged in. There are two more cookies of importance \tt{logged\_in} which is a yes/no value and \tt{dotcom\_user} which is the user's username. To impersonate a user, only the \tt{user\_session} is needed, the \tt{logged\_in} cookie will always be yes and the \tt{dotcom\_user} will be filled by the server if the \tt{user\_session} cookie is valid. When the user logs out, the cookie is invalided by the server in a post request to \tt{https://github.com/logout} that contains the content type and an authenticity token. If an attacker is using the user's cookie and the user logs out, the attacker's cookie will be invalidated.

%Is there any way to get a new cookie without knowing the password?
%What the fuck is the authenticity token? I think it's either a digital signature of the post data, a random nonce or token that the server knows to prevent csrf.

When the user logs in, a post request is sent to \tt{https://github.com/session} with the username, password and authenticity token.

One attack is to guess a random cookie and query to see if it's valid. There are approximately 8 million active github users at a time so roughly 8 million valid cookies. Since you don't need the \tt{logged\_in} cookie to be set correctly, you can construct a random cookie and check if it's valid. The length of the cookie is 80 characters and each character is from the universe (a-z, A-Z, 0-9, -, \_) which has a size of 64. Say the set of correct cookies $S$  has size $|S| = 8,000,000$, the universe $U$ has a size of $|U| = 64^{80}$





\section{User Tracking}
Github does not serve ads as it's business model revolves around selling premium subscriptions. However it does track users for analytics purposes via Google analytics. It does this in two ways:

\begin{enumerate}
\item Google analytics sticks cookies %Which cookies and what do they do?
\item In the rare event that the user removes these cookies, google analytics tries to fingerprint the user. It collects the browser, operating system, extensions installed, model of the computer and a couple other distinguishing factors. This is collected from the \tt{user\_agent} header which contains information such as \tt{Mozilla/5.0 (Macintosh; Intel Mac OS X 10\_10\_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36}. Users who do not allow cookies are even easier to identify than other users as the server identifies that they don't allow cookies and then it's a smaller pool of people that they may be. The remaining identifying information is enough to identify the user. 
\end{enumerate}


\section{CSP}

Content security policy csp



\section{SSL}

All connections to github.com are done via https. This is enforced via HTTP strict transport security (HSTS). Github sets the 


\section{Attack Vectors}
Github relies on the security of git. In one scenario, such as pushing changes to a repository that you don't own 



\section{XSS}

Github has two major protections against cross-site-scripting (XSS) attacks. 


\section{Significance}


\bibliography{iap13}

\end{poster}
\end{document}

